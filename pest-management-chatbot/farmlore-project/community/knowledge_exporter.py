"""
Knowledge Exporter for FarmLore Community Features

This module exports validated indigenous knowledge from the community
to a Prolog knowledge base that can be used by the FarmLore chatbot.
It uses a frame-based representation to match the structure of the main knowledge base.
"""
import os
import sys
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional

# Django imports - uncomment these in the actual implementation
# from django.conf import settings
# from .models import IndigenousKnowledge, KnowledgeKeeper

def export_to_prolog(knowledge_entries, output_file: str) -> None:
    """
    Export community knowledge to Prolog format using frame-based representation.
    
    Args:
        knowledge_entries: List of IndigenousKnowledge objects
        output_file: Path to the output Prolog file
    """
    # Create directory if it doesn't exist
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("% ========================\n")
        f.write("% COMMUNITY KNOWLEDGE BASE\n")
        f.write("% ========================\n")
        f.write("% This file is automatically generated from community contributions\n")
        f.write("% Last updated: {}\n\n".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        
        # Export knowledge entries as Prolog frames
        for entry in knowledge_entries:
            # Convert title to a valid Prolog atom (lowercase, underscores)
            practice_name = entry.title.lower().replace(' ', '_')
            
            # Create a frame for each practice
            f.write("frame(practice, [\n")
            f.write(f"    name: {practice_name},\n")
            f.write(f"    type: {entry.practice_type},\n")
            
            # Add controls (pests) if any
            if entry.pests:
                pests_str = ', '.join(entry.pests)
                f.write(f"    controls: [{pests_str}],\n")
            else:
                f.write(f"    resolves: [low_fertility, poor_organic_matter],\n")
            
            # Add description
            f.write(f"    description: '{entry.description}',\n")
            
            # Add cost and difficulty (estimated)
            f.write(f"    cost: low,\n")
            f.write(f"    difficulty: medium,\n")
            
            # Add materials
            materials_str = ', '.join([f"'{material}'" for material in entry.materials])
            f.write(f"    materials: [{materials_str}],\n")
            
            # Add applicable crops
            crops_str = ', '.join(entry.crops)
            f.write(f"    applicable_crops: [{crops_str}],\n")
            
            # Add season (default to growing_season)
            f.write(f"    season: [growing_season],\n")
            
            # Add source information
            f.write(f"    source: '{entry.keeper.full_name} from {entry.keeper.village}',\n")
            f.write(f"    verification_count: {entry.verification_count},\n")
            
            # Add cultural context
            f.write("    cultural_context: [basotho]\n")
            f.write("]).\n\n")
        
        # Add helper predicates for community knowledge
        f.write("% ========================\n")
        f.write("% HELPER PREDICATES\n")
        f.write("% ========================\n")
        f.write("% Find indigenous practices for controlling a specific pest\n")
        f.write("indigenous_practice_for_pest(Pest, Practice) :-\n")
        f.write("    practice(name:Practice, controls:Controls, cultural_context:Ctx),\n")
        f.write("    member(basotho, Ctx),\n")
        f.write("    member(Pest, Controls).\n\n")
        
        f.write("% Find indigenous practices for a specific crop\n")
        f.write("indigenous_practice_for_crop(Crop, Practice) :-\n")
        f.write("    practice(name:Practice, applicable_crops:Crops, cultural_context:Ctx),\n")
        f.write("    member(basotho, Ctx),\n")
        f.write("    member(Crop, Crops).\n\n")
        
        f.write("% Find verified indigenous practices (verification count >= 3)\n")
        f.write("verified_indigenous_practice(Practice) :-\n")
        f.write("    practice(name:Practice, verification_count:Count, cultural_context:Ctx),\n")
        f.write("    member(basotho, Ctx),\n")
        f.write("    Count >= 3.\n\n")
        
        f.write("% Find all indigenous practices by type\n")
        f.write("indigenous_practices_by_type(Type, Practices) :-\n")
        f.write("    findall(Practice, (\n")
        f.write("        practice(name:Practice, type:Type, cultural_context:Ctx),\n")
        f.write("        member(basotho, Ctx)\n")
        f.write("    ), Practices).\n\n")
        
        f.write("% Integrated queries that combine conventional and indigenous knowledge\n")
        f.write("all_practices_for_pest(Pest, AllPractices) :-\n")
        f.write("    findall(practice(Name, conventional), (\n")
        f.write("        practice(name:Name, controls:Controls, cultural_context:Ctx),\n")
        f.write("        \\+ member(basotho, Ctx),\n")
        f.write("        member(Pest, Controls)\n")
        f.write("    ), ConventionalPractices),\n")
        f.write("    findall(practice(Name, indigenous), (\n")
        f.write("        practice(name:Name, controls:Controls, cultural_context:Ctx),\n")
        f.write("        member(basotho, Ctx),\n")
        f.write("        member(Pest, Controls)\n")
        f.write("    ), IndigenousPractices),\n")
        f.write("    append(ConventionalPractices, IndigenousPractices, AllPractices).\n")
    
    print(f"Exported community knowledge to {output_file}")

def get_verified_knowledge_from_database():
    """
    Get verified indigenous knowledge from the database.
    
    Returns:
        List of verified IndigenousKnowledge objects
    """
    # Import the models here to avoid circular imports
    from .models import IndigenousKnowledge
    
    # Get all verified knowledge entries
    return IndigenousKnowledge.objects.filter(verification_status='verified')

def export_validated_knowledge_to_prolog(output_file: Optional[str] = None) -> str:
    """
    Export validated indigenous knowledge to a Prolog file.
    
    Args:
        output_file: Optional path to the output file. If not provided, a default path is used.
        
    Returns:
        Path to the generated Prolog file
    """
    if output_file is None:
        # Get the project root directory
        base_dir = Path(__file__).resolve().parent.parent
        # Create directory if it doesn't exist
        prolog_dir = base_dir / 'prolog_integration'
        os.makedirs(prolog_dir, exist_ok=True)
        output_file = str(prolog_dir / 'community_kb.pl')
    
    # Get verified knowledge from the database
    knowledge_entries = get_verified_knowledge_from_database()
    
    # Export to Prolog
    export_to_prolog(knowledge_entries, output_file)
    
    # Update the last export timestamp
    from django.utils import timezone
    
    # Store the export timestamp in a file
    timestamp_file = os.path.join(os.path.dirname(output_file), 'last_export.txt')
    with open(timestamp_file, 'w') as f:
        f.write(timezone.now().isoformat())
    
    # Mark all exported entries
    for entry in knowledge_entries:
        entry.mark_as_exported()
    
    return output_file

def check_knowledge_base_includes_community():
    """
    Check if the main knowledge base includes the community knowledge base.
    
    Returns:
        bool: True if the community knowledge base is included, False otherwise
    """
    # Get the project root directory
    base_dir = Path(__file__).resolve().parent.parent
    prolog_dir = base_dir / 'prolog_integration'
    kb_path = prolog_dir / 'knowledgebase.pl'
    
    # If the directory or file doesn't exist yet, return False
    if not prolog_dir.exists():
        os.makedirs(prolog_dir, exist_ok=True)
        return False
        
    if not kb_path.exists():
        # Create an empty knowledgebase file
        with open(kb_path, 'w', encoding='utf-8') as f:
            f.write("% FarmLore Knowledge Base\n")
            f.write("% Created: {}\n\n".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        return False
    
    # Check if the community knowledge is already included
    with open(kb_path, 'r', encoding='utf-8') as f:
        kb_content = f.read()
    
    include_directive = ":- include('community_kb.pl')."
    return include_directive in kb_content

def update_main_knowledge_base() -> bool:
    """
    Update the main knowledge base to include the community knowledge.
    
    This function checks if the main knowledge base already includes the community knowledge,
    and if not, adds an include directive.
    
    Returns:
        bool: True if the knowledge base was updated, False otherwise
    """
    # Get the project root directory
    base_dir = Path(__file__).resolve().parent.parent
    prolog_dir = base_dir / 'prolog_integration'
    kb_path = prolog_dir / 'knowledgebase.pl'
    
    # If the directory doesn't exist, create it
    if not prolog_dir.exists():
        os.makedirs(prolog_dir, exist_ok=True)
    
    # If the file doesn't exist, create it
    if not kb_path.exists():
        with open(kb_path, 'w', encoding='utf-8') as f:
            f.write("% FarmLore Knowledge Base\n")
            f.write("% Created: {}\n\n".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    
    # Check if the community knowledge is already included
    if check_knowledge_base_includes_community():
        print("Community knowledge already included in main knowledge base")
        return True
    
    # Add the include directive to the main knowledge base
    with open(kb_path, 'a', encoding='utf-8') as f:
        f.write("\n\n% Include community knowledge base\n")
        f.write(":- include('community_kb.pl').")
        f.write("\n")
    
    print(f"Updated main knowledge base at {kb_path} to include community knowledge")
    return True

def integrate_community_knowledge():
    """
    Integrate community knowledge with the main knowledge base.
    
    This function exports validated knowledge to Prolog and updates
    the main knowledge base to include the community knowledge.
    
    Returns:
        bool: True if the integration was successful, False otherwise
    """
    try:
        # Export validated knowledge to Prolog
        output_file = export_validated_knowledge_to_prolog()
        
        # Update the main knowledge base if needed
        if not check_knowledge_base_includes_community():
            update_main_knowledge_base()
        
        print("\nCommunity knowledge has been successfully integrated with FarmLore!")
        print("The chatbot can now use indigenous knowledge from the community in its responses.")
        return True
    except Exception as e:
        print(f"Error integrating community knowledge: {str(e)}")
        return False

if __name__ == "__main__":
    integrate_community_knowledge()
